<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>v8 工作原理之数据是如何存储的 | 墨色河东@Blog</title><meta name="author" content="张中医"><meta name="copyright" content="张中医"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栈空间和堆空间：数据是如何存储的JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么 但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚JavaScript 的内存机制了。 其实，要搞清楚 JavaScript 的内存机制并不是">
<meta property="og:type" content="article">
<meta property="og:title" content="v8 工作原理之数据是如何存储的">
<meta property="og:url" content="https://zzystray.github.io/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/index.html">
<meta property="og:site_name" content="墨色河东@Blog">
<meta property="og:description" content="栈空间和堆空间：数据是如何存储的JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么 但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚JavaScript 的内存机制了。 其实，要搞清楚 JavaScript 的内存机制并不是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg">
<meta property="article:published_time" content="2025-06-04T02:40:55.037Z">
<meta property="article:modified_time" content="2025-06-04T03:25:42.486Z">
<meta property="article:author" content="张中医">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "v8 工作原理之数据是如何存储的",
  "url": "https://zzystray.github.io/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/",
  "image": "https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg",
  "datePublished": "2025-06-04T02:40:55.037Z",
  "dateModified": "2025-06-04T03:25:42.486Z",
  "author": [
    {
      "@type": "Person",
      "name": "张中医",
      "url": "https://zzystray.github.io/hexo/"
    }
  ]
}</script><link rel="shortcut icon" href="/hexo/img/avt.icon.ico"><link rel="canonical" href="https://zzystray.github.io/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/hexo/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/hexo/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'v8 工作原理之数据是如何存储的',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/3s.jpg" onerror="this.onerror=null;this.src='/hexo/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/hexo/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/hexo/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/hexo/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/archives/"><i class="fa-fw fas fa-archive"></i><span> 成就</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 说明</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo/music/"><i class="fa-fw fas fa-music"></i><span> 说明1</span></a></li><li><a class="site-page child" href="/hexo/movies/"><i class="fa-fw fas fa-video"></i><span> 说明2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo/project/"><i class="fa-fw fas fa-link"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/hexo/"></a><a class="nav-page-title" href="/hexo/"><span class="site-name">v8 工作原理之数据是如何存储的</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/hexo/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/archives/"><i class="fa-fw fas fa-archive"></i><span> 成就</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 说明</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/hexo/music/"><i class="fa-fw fas fa-music"></i><span> 说明1</span></a></li><li><a class="site-page child" href="/hexo/movies/"><i class="fa-fw fas fa-video"></i><span> 说明2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/hexo/project/"><i class="fa-fw fas fa-link"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/hexo/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">v8 工作原理之数据是如何存储的</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T02:40:55.037Z" title="发表于 2025-06-04 10:40:55">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T03:25:42.486Z" title="更新于 2025-06-04 11:25:42">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="栈空间和堆空间：数据是如何存储的"><a href="#栈空间和堆空间：数据是如何存储的" class="headerlink" title="栈空间和堆空间：数据是如何存储的"></a>栈空间和堆空间：数据是如何存储的</h1><p>JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么</p>
<p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚JavaScript 的内存机制了。</p>
<p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p>
<p>今天我们讲述第一部分的内容——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的</p>
<h2 id="让人疑惑的代码"><a href="#让人疑惑的代码" class="headerlink" title="#让人疑惑的代码"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#%E8%AE%A9%E4%BA%BA%E7%96%91%E6%83%91%E7%9A%84%E4%BB%A3%E7%A0%81">#</a>让人疑惑的代码</h2><p>首先，我们先看下面这两段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    a.<span class="property">name</span> = <span class="string">&quot; 极客邦 &quot;</span> </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p>
<p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p>
<p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是{name:”极客邦”}。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p>
<p>要彻底弄清楚这个问题，我们就得先从“JavaScript 是什么类型的语言”讲起。</p>
<h2 id="JavaScript-是什么类型的语言"><a href="#JavaScript-是什么类型的语言" class="headerlink" title="#JavaScript 是什么类型的语言"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#javascript-%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80">#</a>JavaScript 是什么类型的语言</h2><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span>* b = <span class="string">&quot; 极客时间 &quot;</span>;</span><br><span class="line">   <span class="type">bool</span> c = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</p>
<p>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>
<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a</span><br></pre></td></tr></table></figure>

<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>
<p>对于各种语言的类型，你可以参考下图</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/2.png" alt="img"></p>
<h2 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="#JavaScript 的数据类型"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">#</a>JavaScript 的数据类型</h2><p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>
<ul>
<li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据</li>
</ul>
<p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line">bar = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>
<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar)  <span class="comment">//undefined</span></span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//number</span></span><br><span class="line">bar = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar)<span class="comment">//string</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//boolean</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br><span class="line">bar = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>
<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/3.png" alt="img"></p>
<p>了解这些类型之后，还有三点需要你注意一下。</p>
<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>
<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;极客时间&#x27;</span>,</span><br><span class="line">  <span class="attr">update</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>
<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>
<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="#内存空间"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4">#</a>内存空间</h2><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/4.png" alt="img"></p>
<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>
<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>
<h2 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="#栈空间和堆空间"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4">#</a>栈空间和堆空间</h2><p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/5.png" alt="img"></p>
<p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p>
<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/6.png" alt="img"></p>
<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>
<p>好了，现在你应该知道了原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>
<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/7.png" alt="img"></p>
<p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>
<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p>
<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>
<p>所以d&#x3D;c的操作就是把 c 的引用地址赋值给 d，你可以参考下图</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/8.png" alt="img"></p>
<p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p>
<h2 id="再谈闭包"><a href="#再谈闭包" class="headerlink" title="#再谈闭包"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#%E5%86%8D%E8%B0%88%E9%97%AD%E5%8C%85">#</a>再谈闭包</h2><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123; </span><br><span class="line">        <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">newName</span>)&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>()</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.<span class="title function_">getName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure>

<p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p>
<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>
<ul>
<li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li>
<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo - 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>
<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li>
<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中</li>
</ul>
<p>通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：</p>
<p><img src="https://blog.poetries.top/img/static/gitee/2019/11/9.png" alt="img"></p>
<p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。</p>
<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。</p>
<p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p>
<p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p>
<p>最后，我们还站在内存模型的视角分析了闭包的产生过程</p>
<h2 id="思考时间"><a href="#思考时间" class="headerlink" title="#思考时间"></a><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4">#</a>思考时间</h2><p>在实际的项目中，经常需要完整地拷贝一个对象，也就是说拷贝完成之后两个对象之间就不能互相影响。那该如何实现呢？</p>
<p>结合下面这段代码，你可以分析下它是如何将对象 jack 拷贝给 jack2，然后在完成拷贝操作时两个 jack 还互不影响的呢。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jack = &#123;</span><br><span class="line">    name : <span class="string">&quot;jack.ma&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">40</span>,</span><br><span class="line">    <span class="attr">like</span>:&#123;</span><br><span class="line">        <span class="attr">dog</span>:&#123;</span><br><span class="line">            <span class="attr">color</span>:<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">3</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">cat</span>:&#123;</span><br><span class="line">            <span class="attr">color</span>:<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">src</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dest</span><br><span class="line">    <span class="comment">// 实现拷贝代码，将 src 的值完整地拷贝给 dest</span></span><br><span class="line">   <span class="comment">// 在这里实现</span></span><br><span class="line">    <span class="keyword">return</span> dest</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jack2 = <span class="title function_">copy</span>(jack)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 比如修改 jack2 中的内容，不会影响到 jack 中的值</span></span><br><span class="line">jack2.<span class="property">like</span>.<span class="property">dog</span>.<span class="property">color</span> = <span class="string">&#x27;green&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jack.<span class="property">like</span>.<span class="property">dog</span>.<span class="property">color</span>) <span class="comment">// 打印出来的应该是 &quot;black&quot;</span></span><br></pre></td></tr></table></figure>

<p>关于foo函数执行上下文销毁过程：foo函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo函数的执行上下文的那块数据就挪出来，这也就是foo函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。</p>
<p>第二个问题：innerBar返回后，含有setName和getName对象，这两个对象里面包含了堆中的closure(foo)的引用。虽然foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用。</p>
<p>你可以：</p>
<ul>
<li>打开“开发者工具”</li>
<li>在控制台执行上述代码</li>
<li>然后选择“Memory”标签，点击”take snapshot” 获取V8的堆内存快照。</li>
<li>然后“command+f”(mac) 或者 “ctrl+f”(win),搜索“setName”，然后你就会发现setName对象下面包含了 <code>raw_outer_scope_info_or_feedback_metadata</code>，对闭包的引用数据就在这里面。&#96;</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://ZZYstray.github.io/hexo">张中医</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zzystray.github.io/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/">https://zzystray.github.io/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ZZYstray.github.io/hexo" target="_blank">墨色河东@Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/hexo/2025/05/30/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/hexo/2025/06/04/%E8%99%9A%E6%8B%9FDOM%EF%BC%9A%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%AE%9E%E9%99%85DOM%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/" title="虚拟DOM和实际DOM有何不同"><img class="cover" src="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/10s.jpg" onerror="onerror=null;src='/hexo/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">虚拟DOM和实际DOM有何不同</div></div><div class="info-2"><div class="info-item-1">虚拟DOM：虚拟DOM和实际DOM有何不同虚拟 DOM 是最近非常火的技术，两大著名前端框架 React 和 Vue 都使用了虚拟 DOM，所以我觉得非常有必要结合浏览器的工作机制对虚拟 DOM 进行一次分析。当然了，React 和 Vue 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 DOM 上。 在本文我们会先聊聊 DOM 的一些缺陷，然后在此基础上介绍虚拟 DOM 是如何解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM。 #DOM 的缺陷通过 JavaScript 操纵 DOM 会影响到整个渲染流水线的。另外，DOM 还提供了一组 JavaScript 接口用来遍历或者修改节点，这套接口包含了 getElementById、removeChild、appendChild 等方法。 比如，我们可以调用document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/3s.jpg" onerror="this.onerror=null;this.src='/hexo/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">张中医</div><div class="author-info-description"></div><div class="site-data"><a href="/hexo/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/hexo/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/hexo/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZZYstray"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">栈空间和堆空间：数据是如何存储的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9%E4%BA%BA%E7%96%91%E6%83%91%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">让人疑惑的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">JavaScript 是什么类型的语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">JavaScript 的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.</span> <span class="toc-text">内存空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">栈空间和堆空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E9%97%AD%E5%8C%85"><span class="toc-number">1.6.</span> <span class="toc-text">再谈闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4"><span class="toc-number">1.8.</span> <span class="toc-text">思考时间</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/hexo/2025/06/04/%E8%99%9A%E6%8B%9FDOM%EF%BC%9A%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%AE%9E%E9%99%85DOM%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/" title="虚拟DOM和实际DOM有何不同"><img src="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/10s.jpg" onerror="this.onerror=null;this.src='/hexo/img/404.jpg'" alt="虚拟DOM和实际DOM有何不同"/></a><div class="content"><a class="title" href="/hexo/2025/06/04/%E8%99%9A%E6%8B%9FDOM%EF%BC%9A%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%AE%9E%E9%99%85DOM%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/" title="虚拟DOM和实际DOM有何不同">虚拟DOM和实际DOM有何不同</a><time datetime="2025-06-04T06:10:24.097Z" title="发表于 2025-06-04 14:10:24">2025-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/" title="v8 工作原理之数据是如何存储的"><img src="https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg" onerror="this.onerror=null;this.src='/hexo/img/404.jpg'" alt="v8 工作原理之数据是如何存储的"/></a><div class="content"><a class="title" href="/hexo/2025/06/04/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/" title="v8 工作原理之数据是如何存储的">v8 工作原理之数据是如何存储的</a><time datetime="2025-06-04T02:40:55.037Z" title="发表于 2025-06-04 10:40:55">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/hexo/2025/05/30/hello-world/" title="Hello World">Hello World</a><time datetime="2025-05-30T09:19:38.278Z" title="发表于 2025-05-30 17:19:38">2025-05-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://lyl123-1313213610.cos.ap-guangzhou.myqcloud.com/8s.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 张中医</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/hexo/js/utils.js"></script><script src="/hexo/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>